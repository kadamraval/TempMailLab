{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the TempInbox application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user entity."
        },
        "email": {
          "type": "string",
          "description": "User's email address (optional, for login).",
          "format": "email"
        },
        "googleId": {
          "type": "string",
          "description": "User's Google ID (optional, for Google login)."
        },
        "premium": {
          "type": "boolean",
          "description": "Indicates if the user has a premium (ad-free) subscription."
        }
      },
      "required": [
        "id"
      ]
    },
    "Inbox": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Inbox",
      "type": "object",
      "description": "Represents a temporary email inbox.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the inbox entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Inbox)"
        },
        "emailAddress": {
          "type": "string",
          "description": "The temporary email address of the inbox."
        },
        "creationTime": {
          "type": "string",
          "description": "Timestamp indicating when the inbox was created.",
          "format": "date-time"
        },
        "expirationTime": {
          "type": "string",
          "description": "Timestamp indicating when the inbox will expire.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "emailAddress",
        "creationTime",
        "expirationTime"
      ]
    },
    "Email": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Email",
      "type": "object",
      "description": "Represents an email message received in an inbox.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the email entity."
        },
        "inboxId": {
          "type": "string",
          "description": "Reference to Inbox. (Relationship: Inbox 1:N Email)"
        },
        "senderName": {
          "type": "string",
          "description": "Name of the email sender."
        },
        "subject": {
          "type": "string",
          "description": "Subject line of the email."
        },
        "receivedTime": {
          "type": "string",
          "description": "Timestamp indicating when the email was received.",
          "format": "date-time"
        },
        "htmlContent": {
          "type": "string",
          "description": "HTML content of the email."
        },
        "plainTextContent": {
          "type": "string",
          "description": "Plain text content of the email."
        }
      },
      "required": [
        "id",
        "inboxId",
        "senderName",
        "subject",
        "receivedTime"
      ]
    },
    "ApiKey": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApiKey",
      "type": "object",
      "description": "Represents an API key for developer access.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the API key entity."
        },
        "developerId": {
          "type": "string",
          "description": "Reference to User (representing the developer). (Relationship: User 1:N ApiKey)"
        },
        "apiKey": {
          "type": "string",
          "description": "The actual API key value."
        },
        "creationTime": {
          "type": "string",
          "description": "Timestamp indicating when the API key was created.",
          "format": "date-time"
        },
        "usageLimit": {
          "type": "number",
          "description": "The maximum number of API calls allowed."
        }
      },
      "required": [
        "id",
        "developerId",
        "apiKey",
        "creationTime",
        "usageLimit"
      ]
    },
    "ApiLog": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApiLog",
      "type": "object",
      "description": "Represents a log entry for API usage.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the API log entry."
        },
        "apiKeyId": {
          "type": "string",
          "description": "Reference to ApiKey. (Relationship: ApiKey 1:N ApiLog)"
        },
        "requestTime": {
          "type": "string",
          "description": "Timestamp of the API request.",
          "format": "date-time"
        },
        "endpoint": {
          "type": "string",
          "description": "The API endpoint that was called."
        },
        "requestBody": {
          "type": "string",
          "description": "The request body (optional, for debugging)."
        },
        "responseCode": {
          "type": "number",
          "description": "The HTTP response code."
        }
      },
      "required": [
        "id",
        "apiKeyId",
        "requestTime",
        "endpoint",
        "responseCode"
      ]
    },
    "BlockedIp": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlockedIp",
      "type": "object",
      "description": "Represents a blocked IP address.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the blocked IP."
        },
        "ipAddress": {
          "type": "string",
          "description": "The blocked IP address."
        },
        "blockTime": {
          "type": "string",
          "description": "Timestamp of when the IP was blocked.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "ipAddress",
        "blockTime"
      ]
    },
    "BlockedDomain": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlockedDomain",
      "type": "object",
      "description": "Represents a blocked sender domain.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the blocked domain."
        },
        "domain": {
          "type": "string",
          "description": "The blocked sender domain."
        },
        "blockTime": {
          "type": "string",
          "description": "Timestamp of when the domain was blocked.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "domain",
        "blockTime"
      ]
    },
    "UserSession": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserSession",
      "type": "object",
      "description": "Represents an active user session.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user session."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N UserSession)"
        },
        "loginTime": {
          "type": "string",
          "description": "Timestamp of when the user logged in.",
          "format": "date-time"
        },
        "lastActivityTime": {
          "type": "string",
          "description": "Timestamp of the user's last activity.",
          "format": "date-time"
        },
        "ipAddress": {
          "type": "string",
          "description": "The IP address of the user's session."
        }
      },
      "required": [
        "id",
        "userId",
        "loginTime",
        "lastActivityTime",
        "ipAddress"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. Uses path-based ownership for all user-related data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/inboxes/{inboxId}",
        "definition": {
          "entityName": "Inbox",
          "schema": {
            "$ref": "#/backend/entities/Inbox"
          },
          "description": "Stores temporary email inboxes for each user. Uses path-based ownership. Stores `userId` to enable list operations and rule independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "inboxId",
              "description": "The unique identifier for the inbox."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/inboxes/{inboxId}/emails/{emailId}",
        "definition": {
          "entityName": "Email",
          "schema": {
            "$ref": "#/backend/entities/Email"
          },
          "description": "Stores email messages for each inbox. Uses path-based ownership. Stores `inboxId` to enable list operations and rule independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "inboxId",
              "description": "The unique identifier for the inbox."
            },
            {
              "name": "emailId",
              "description": "The unique identifier for the email."
            }
          ]
        }
      },
      {
        "path": "/users/{developerId}/apiKeys/{apiKeyId}",
        "definition": {
          "entityName": "ApiKey",
          "schema": {
            "$ref": "#/backend/entities/ApiKey"
          },
          "description": "Stores API keys for developers. Uses path-based ownership. Stores `developerId` to enable list operations and rule independence.",
          "params": [
            {
              "name": "developerId",
              "description": "The unique identifier for the developer (user)."
            },
            {
              "name": "apiKeyId",
              "description": "The unique identifier for the API key."
            }
          ]
        }
      },
      {
        "path": "/users/{developerId}/apiKeys/{apiKeyId}/apiLogs/{apiLogId}",
        "definition": {
          "entityName": "ApiLog",
          "schema": {
            "$ref": "#/backend/entities/ApiLog"
          },
          "description": "Stores API usage logs for each API key. Uses path-based ownership. Stores `apiKeyId` to enable list operations and rule independence.",
          "params": [
            {
              "name": "developerId",
              "description": "The unique identifier for the developer (user)."
            },
            {
              "name": "apiKeyId",
              "description": "The unique identifier for the API key."
            },
            {
              "name": "apiLogId",
              "description": "The unique identifier for the API log entry."
            }
          ]
        }
      },
      {
        "path": "/blockedIps/{blockedIpId}",
        "definition": {
          "entityName": "BlockedIp",
          "schema": {
            "$ref": "#/backend/entities/BlockedIp"
          },
          "description": "Stores blocked IP addresses. Admin-only access.",
          "params": [
            {
              "name": "blockedIpId",
              "description": "The unique identifier for the blocked IP address."
            }
          ]
        }
      },
      {
        "path": "/blockedDomains/{blockedDomainId}",
        "definition": {
          "entityName": "BlockedDomain",
          "schema": {
            "$ref": "#/backend/entities/BlockedDomain"
          },
          "description": "Stores blocked sender domains. Admin-only access.",
          "params": [
            {
              "name": "blockedDomainId",
              "description": "The unique identifier for the blocked domain."
            }
          ]
        }
      },
      {
        "path": "/userSessions/{userSessionId}",
        "definition": {
          "entityName": "UserSession",
          "schema": {
            "$ref": "#/backend/entities/UserSession"
          },
          "description": "Stores active user sessions.  Admin-only access to list all sessions. Users can only access their own sessions.",
          "params": [
            {
              "name": "userSessionId",
              "description": "The unique identifier for the user session."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "roles_admin",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Collection to store admin user IDs. The existence of a document indicates admin role.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the admin user."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to ensure security, scalability, and ease of debugging, adhering to the principles of Authorization Independence, Clarity of Intent, DBAC, and QAPs. \n\n**Authorization Independence:**  Authorization independence is achieved primarily through path-based ownership for user-related data. For example, inboxes and emails are stored under `/users/{userId}` to ensure that rules can verify ownership without needing to read parent documents. API keys and logs are similarly structured, tying them directly to the developer.\n\n**Structural Segregation:** The structure segregates data based on access requirements. User-specific data like inboxes and emails are stored in user-specific subcollections (e.g., `/users/{userId}/inboxes/{inboxId}`), ensuring that listing inboxes requires only knowledge of the user's ID and doesn't leak data from other users.\n\n**Access Modeling:** Access is modeled using path-based ownership.  User owns Inboxes, and Inboxes own Emails. Admins can access blocked IPs and domains, leveraging existence checks in the rules to determine admin privileges. API keys and logs follow a similar pattern. \n\n**QAPs Support:** The structure supports secure `list` operations through segregation. Listing inboxes is secure because inboxes are stored under the user's ID. Similarly, admin-level listing of blocked IPs or domains is secured via role-based access control (existence check of `/roles_admin/{uid}`). The membership map approach (while not applicable here) is the standard for collaborative data.\n\n**Invariants:** The structure facilitates the enforcement of invariants. Ownership is clear via path-based structures. Timestamps can be enforced through rules upon creation. Denormalization is kept to a minimum and ownership information is implicit in document paths."
  }
}