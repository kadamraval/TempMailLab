{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the TempInbox application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "email": {
          "type": "string",
          "description": "User's email address (for login if not using Google)."
        },
        "googleId": {
          "type": "string",
          "description": "Google ID of the user, if logged in with Google."
        },
        "premium": {
          "type": "boolean",
          "description": "Indicates if the user has a premium (ad-free) account."
        },
        "apiKeyId": {
          "type": "string",
          "description": "Reference to ApiKey. (Relationship: User 1:N ApiKey)"
        }
      },
      "required": [
        "id"
      ]
    },
    "TempInbox": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TempInbox",
      "type": "object",
      "description": "Represents a temporary email inbox.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the temporary inbox."
        },
        "emailAddress": {
          "type": "string",
          "description": "The full email address of the temporary inbox."
        },
        "expirationTime": {
          "type": "string",
          "description": "The date and time when the inbox will expire.",
          "format": "date-time"
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N TempInbox).  The user who created or owns this inbox. Null if anonymous."
        }
      },
      "required": [
        "id",
        "emailAddress",
        "expirationTime"
      ]
    },
    "Email": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Email",
      "type": "object",
      "description": "Represents a single email message received in a temporary inbox.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the email message."
        },
        "inboxId": {
          "type": "string",
          "description": "Reference to TempInbox. (Relationship: TempInbox 1:N Email). The inbox this email belongs to."
        },
        "senderName": {
          "type": "string",
          "description": "The name of the email sender."
        },
        "subject": {
          "type": "string",
          "description": "The subject line of the email."
        },
        "receivedTime": {
          "type": "string",
          "description": "The date and time when the email was received.",
          "format": "date-time"
        },
        "htmlContent": {
          "type": "string",
          "description": "The HTML content of the email."
        },
        "plainTextContent": {
          "type": "string",
          "description": "The plain text content of the email."
        }
      },
      "required": [
        "id",
        "inboxId",
        "receivedTime"
      ]
    },
    "AdminSession": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AdminSession",
      "type": "object",
      "description": "Represents an active admin session.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the admin session."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N AdminSession). The admin user associated with this session."
        },
        "loginTime": {
          "type": "string",
          "description": "The date and time when the admin session started.",
          "format": "date-time"
        },
        "lastActiveTime": {
          "type": "string",
          "description": "The date and time the admin session was last active.",
          "format": "date-time"
        },
        "ipAddress": {
          "type": "string",
          "description": "The IP address of the admin session."
        }
      },
      "required": [
        "id",
        "userId",
        "loginTime"
      ]
    },
    "BlockedIp": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlockedIp",
      "type": "object",
      "description": "Represents a blocked IP address.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the blocked IP address."
        },
        "ipAddress": {
          "type": "string",
          "description": "The blocked IP address."
        },
        "blockTime": {
          "type": "string",
          "description": "The time when the IP address was blocked.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "ipAddress",
        "blockTime"
      ]
    },
    "BlockedDomain": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlockedDomain",
      "type": "object",
      "description": "Represents a blocked sender domain.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the blocked domain."
        },
        "domain": {
          "type": "string",
          "description": "The blocked sender domain."
        },
        "blockTime": {
          "type": "string",
          "description": "The time when the domain was blocked.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "domain",
        "blockTime"
      ]
    },
    "ApiKey": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApiKey",
      "type": "object",
      "description": "Represents an API key for developer access.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the API key."
        },
        "key": {
          "type": "string",
          "description": "The API key value."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N ApiKey). The user who owns this API key."
        },
        "creationTime": {
          "type": "string",
          "description": "The date and time when the API key was created.",
          "format": "date-time"
        },
        "planId": {
          "type": "string",
          "description": "Reference to ApiPlan. (Relationship: ApiKey 1:1 ApiPlan).  The API plan associated with this key."
        }
      },
      "required": [
        "id",
        "key",
        "userId",
        "creationTime"
      ]
    },
    "ApiPlan": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApiPlan",
      "type": "object",
      "description": "Represents a paid API plan.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the API plan."
        },
        "name": {
          "type": "string",
          "description": "The name of the API plan."
        },
        "rateLimit": {
          "type": "number",
          "description": "The rate limit for this API plan (requests per time unit)."
        },
        "price": {
          "type": "number",
          "description": "The price of the API plan."
        }
      },
      "required": [
        "id",
        "name",
        "rateLimit",
        "price"
      ]
    },
    "ApiUsageLog": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApiUsageLog",
      "type": "object",
      "description": "Represents a log entry for API usage.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the API usage log entry."
        },
        "apiKeyId": {
          "type": "string",
          "description": "Reference to ApiKey. (Relationship: ApiKey 1:N ApiUsageLog). The API key that was used."
        },
        "timestamp": {
          "type": "string",
          "description": "The date and time of the API usage.",
          "format": "date-time"
        },
        "endpoint": {
          "type": "string",
          "description": "The API endpoint that was accessed."
        },
        "requestBody": {
          "type": "string",
          "description": "The request body of the API call."
        },
        "responseCode": {
          "type": "number",
          "description": "The HTTP response code of the API call."
        }
      },
      "required": [
        "id",
        "apiKeyId",
        "timestamp",
        "endpoint"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles.  Owned by the user identified by userId.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/tempInboxes/{tempInboxId}",
        "definition": {
          "entityName": "TempInbox",
          "schema": {
            "$ref": "#/backend/entities/TempInbox"
          },
          "description": "Stores temporary inboxes for each user. Owned by the user identified by userId.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "tempInboxId",
              "description": "The unique identifier for the temporary inbox."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/tempInboxes/{tempInboxId}/emails/{emailId}",
        "definition": {
          "entityName": "Email",
          "schema": {
            "$ref": "#/backend/entities/Email"
          },
          "description": "Stores emails for each temporary inbox. Owned by the user identified by userId, within tempInboxId.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "tempInboxId",
              "description": "The unique identifier for the temporary inbox."
            },
            {
              "name": "emailId",
              "description": "The unique identifier for the email."
            }
          ]
        }
      },
      {
        "path": "/apiKeys/{apiKeyId}",
        "definition": {
          "entityName": "ApiKey",
          "schema": {
            "$ref": "#/backend/entities/ApiKey"
          },
          "description": "Stores API keys. Each API key is associated with a userId. Enforces secure list operations. Denormalized `userId` is stored within the apiKey document for Authorization Independence.",
          "params": [
            {
              "name": "apiKeyId",
              "description": "The unique identifier for the API key."
            }
          ]
        }
      },
      {
        "path": "/apiKeys/{apiKeyId}/usageLogs/{apiUsageLogId}",
        "definition": {
          "entityName": "ApiUsageLog",
          "schema": {
            "$ref": "#/backend/entities/ApiUsageLog"
          },
          "description": "Stores API usage logs for each API key.  Associated with apiKeyId.",
          "params": [
            {
              "name": "apiKeyId",
              "description": "The unique identifier for the API key."
            },
            {
              "name": "apiUsageLogId",
              "description": "The unique identifier for the API usage log entry."
            }
          ]
        }
      },
      {
        "path": "/apiPlans/{apiPlanId}",
        "definition": {
          "entityName": "ApiPlan",
          "schema": {
            "$ref": "#/backend/entities/ApiPlan"
          },
          "description": "Stores API plans.",
          "params": [
            {
              "name": "apiPlanId",
              "description": "The unique identifier for the API plan."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "AdminSession",
          "schema": {
            "$ref": "#/backend/entities/AdminSession"
          },
          "description": "Collection to store admin user IDs, existence implies admin role.  Existence over content, DBAC. Enables secure list operations.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the admin user."
            }
          ]
        }
      },
      {
        "path": "/blockedIps/{blockedIpId}",
        "definition": {
          "entityName": "BlockedIp",
          "schema": {
            "$ref": "#/backend/entities/BlockedIp"
          },
          "description": "Stores blocked IP addresses.",
          "params": [
            {
              "name": "blockedIpId",
              "description": "The unique identifier for the blocked IP address."
            }
          ]
        }
      },
      {
        "path": "/blockedDomains/{blockedDomainId}",
        "definition": {
          "entityName": "BlockedDomain",
          "schema": {
            "$ref": "#/backend/entities/BlockedDomain"
          },
          "description": "Stores blocked sender domains.",
          "params": [
            {
              "name": "blockedDomainId",
              "description": "The unique identifier for the blocked domain."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to ensure authorization independence, clarity, and scalability. User data and inboxes are stored in separate, user-specific subcollections for easy management and security. Admin-related data is kept in separate collections with appropriate security rules. API keys and usage logs are also separated for efficient tracking and management. Denormalization is used where necessary to avoid complex `get()` calls in security rules, particularly for collaborative data scenarios and to enable atomic operations. This design facilitates secure `list` operations by ensuring homogeneous security postures within each collection."
  }
}