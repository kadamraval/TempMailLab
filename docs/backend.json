{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the TempInbox application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "User's email address (used for login if not using Google).",
          "format": "email"
        },
        "googleId": {
          "type": "string",
          "description": "User's Google ID (if logged in with Google)."
        },
        "isPremium": {
          "type": "boolean",
          "description": "Indicates if the user has a premium (ad-free) account."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the user account was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id"
      ]
    },
    "Inbox": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Inbox",
      "type": "object",
      "description": "Represents a temporary email inbox.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Inbox entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Inbox)"
        },
        "emailAddress": {
          "type": "string",
          "description": "The temporary email address for this inbox."
        },
        "expirationTime": {
          "type": "string",
          "description": "Timestamp indicating when the inbox will expire.",
          "format": "date-time"
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the inbox was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "emailAddress",
        "expirationTime"
      ]
    },
    "Email": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Email",
      "type": "object",
      "description": "Represents a single email message within an inbox.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Email entity."
        },
        "inboxId": {
          "type": "string",
          "description": "Reference to Inbox. (Relationship: Inbox 1:N Email)"
        },
        "senderName": {
          "type": "string",
          "description": "Name of the sender."
        },
        "subject": {
          "type": "string",
          "description": "Subject line of the email."
        },
        "receivedAt": {
          "type": "string",
          "description": "Timestamp indicating when the email was received.",
          "format": "date-time"
        },
        "htmlContent": {
          "type": "string",
          "description": "HTML content of the email."
        },
        "textContent": {
          "type": "string",
          "description": "Plain text content of the email."
        }
      },
      "required": [
        "id",
        "inboxId",
        "senderName",
        "subject",
        "receivedAt"
      ]
    },
    "ApiKey": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApiKey",
      "type": "object",
      "description": "Represents a developer API key for accessing the TempInbox API.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ApiKey entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N ApiKey). Represents the user/developer who owns the API key."
        },
        "apiKey": {
          "type": "string",
          "description": "The actual API key value."
        },
        "usageLimit": {
          "type": "number",
          "description": "The maximum number of API calls allowed per time period."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the API key was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "apiKey",
        "usageLimit"
      ]
    },
    "UsageLog": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UsageLog",
      "type": "object",
      "description": "Represents a log entry for API key usage.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the UsageLog entity."
        },
        "apiKeyId": {
          "type": "string",
          "description": "Reference to ApiKey. (Relationship: ApiKey 1:N UsageLog)"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of the API call.",
          "format": "date-time"
        },
        "endpoint": {
          "type": "string",
          "description": "The API endpoint that was called."
        },
        "requestBody": {
          "type": "string",
          "description": "The request body (optional)."
        }
      },
      "required": [
        "id",
        "apiKeyId",
        "timestamp",
        "endpoint"
      ]
    },
    "BlockedIp": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlockedIp",
      "type": "object",
      "description": "Stores blocked IP addresses.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the BlockedIp entity."
        },
        "ipAddress": {
          "type": "string",
          "description": "The blocked IP address."
        },
        "reason": {
          "type": "string",
          "description": "The reason for blocking the IP address."
        },
        "blockedAt": {
          "type": "string",
          "description": "Timestamp indicating when the IP address was blocked.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "ipAddress"
      ]
    },
    "BlockedDomain": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlockedDomain",
      "type": "object",
      "description": "Stores blocked sender domains.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the BlockedDomain entity."
        },
        "domain": {
          "type": "string",
          "description": "The blocked sender domain."
        },
        "reason": {
          "type": "string",
          "description": "The reason for blocking the domain."
        },
        "blockedAt": {
          "type": "string",
          "description": "Timestamp indicating when the domain was blocked.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "domain"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user data. Root path for user-owned data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/inboxes/{inboxId}",
        "definition": {
          "entityName": "Inbox",
          "schema": {
            "$ref": "#/backend/entities/Inbox"
          },
          "description": "Stores temporary email inboxes for each user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "inboxId",
              "description": "The unique identifier of the inbox."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/inboxes/{inboxId}/emails/{emailId}",
        "definition": {
          "entityName": "Email",
          "schema": {
            "$ref": "#/backend/entities/Email"
          },
          "description": "Stores emails within each inbox. Includes denormalized 'inboxId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "inboxId",
              "description": "The unique identifier of the inbox."
            },
            {
              "name": "emailId",
              "description": "The unique identifier of the email."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/api_keys/{apiKeyId}",
        "definition": {
          "entityName": "ApiKey",
          "schema": {
            "$ref": "#/backend/entities/ApiKey"
          },
          "description": "Stores API keys for each user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "apiKeyId",
              "description": "The unique identifier of the API key."
            }
          ]
        }
      },
      {
        "path": "/api_keys/{apiKeyId}/usage_logs/{usageLogId}",
        "definition": {
          "entityName": "UsageLog",
          "schema": {
            "$ref": "#/backend/entities/UsageLog"
          },
          "description": "Stores usage logs for each API key. Includes denormalized 'apiKeyId' for authorization independence.",
          "params": [
            {
              "name": "apiKeyId",
              "description": "The unique identifier of the API key."
            },
            {
              "name": "usageLogId",
              "description": "The unique identifier of the usage log."
            }
          ]
        }
      },
      {
        "path": "/blocked_ips/{blockedIpId}",
        "definition": {
          "entityName": "BlockedIp",
          "schema": {
            "$ref": "#/backend/entities/BlockedIp"
          },
          "description": "Stores blocked IP addresses. Accessible only by admins.",
          "params": [
            {
              "name": "blockedIpId",
              "description": "The unique identifier of the blocked IP."
            }
          ]
        }
      },
      {
        "path": "/blocked_domains/{blockedDomainId}",
        "definition": {
          "entityName": "BlockedDomain",
          "schema": {
            "$ref": "#/backend/entities/BlockedDomain"
          },
          "description": "Stores blocked sender domains. Accessible only by admins.",
          "params": [
            {
              "name": "blockedDomainId",
              "description": "The unique identifier of the blocked domain."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "roles_admin",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Indicates admin role. Document existence grants admin privileges.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to ensure security, scalability, and debuggability, adhering to the core principles of Authorization Independence, Clarity of Intent, DBAC (Database-Based Access Control), and QAPs (Rules are not Filters).  It leverages denormalization for authorization and structural segregation based on access requirements.\n\nAuthorization Independence is achieved by denormalizing user IDs and any other relevant authorization data (e.g., for collaborative inboxes, potentially membership maps) directly into the documents where access needs to be controlled. This avoids the need for `get()` calls in security rules, enabling atomic operations.\n\nQAPs (Rules are not Filters) is supported through structural segregation. For example, blocked IPs and domains are stored in dedicated collections with restricted access rules, preventing them from being listed or accessed by unauthorized users. User-owned data is segregated using hierarchical paths, ensuring only the owning user can list or access their inboxes and emails.  Admin roles are managed via the existence of documents in dedicated `/roles_admin/{uid}` collections.\n\nSpecific denormalization strategies:\n\n*   `Inboxes`: The `userId` is stored within each inbox document to directly link it to the owner.  This avoids needing to query or `get()` the user document to check ownership.\n*   `Emails`: The `inboxId` is stored within each email document to associate with its parent inbox. Again, this is done to simplify querying for emails within a specific inbox and for authorization rules.\n*   `ApiKeys` & `UsageLogs`: Both have `userId` or `apiKeyId` respectively denormalized to allow direct filtering and easier rule definitions to control access by the owning user or to the related ApiKey.\n\nAdmin collections like `/blocked_ips` and `/blocked_domains` are completely segregated, and write access is granted only to users with an admin role (verified through the presence of a document in the `/roles_admin/{uid}` collection)."
  }
}